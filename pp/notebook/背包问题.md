# 背包问题

1. 注意dp的状态转移方程，不应该光为
$$
dp[i][j] = max(dp[i - 1][j] ,dp[i - 1][j - val] + sorce )
$$
在无法进行选择的地方使用如下表达式，这表明，在$dp[i - 1][j]$的情况下强制不能选择第i件物品。
$$
dp[i][j] = dp[i - 1][j]
$$

[noip 2005 普及组 采药](https://www.luogu.com.cn/problem/P1048)
```cpp
#include<bits/stdc++.h>

using namespace std;
const int maxx = 1e3 + 1;
int dp[2][maxx];

int main()
{
  int t,m;
  cin>>t>>m;
  memset(dp,0,sizeof(dp));
  int ans = 0;
  for(int i = 1;i <= m;i++) {
    int time_val,val;
    scanf("%d%d",&time_val,&val);
    for(int j = 0;j <= t;j++){
      if(j < time_val){
        dp[(i) % 2][j] = dp[(i - 1) % 2][j];
        continue;
      }
      dp[i % 2][j] = max(dp[(i- 1) % 2][j], dp[(i - 1) % 2][j - time_val] + val);
      ans = max(ans, dp[(i % 2)][j]);
    }
  }
  cout << ans<<endl;
  return 0;
}

```

2. 背包问题简言之就是多个物品拿还是取所对应的价值的最优解。

### [NOIP2001 普及组] 装箱问题

#### 题目描述

有一个箱子容量为 $V$，同时有 $n$ 个物品，每个物品有一个体积。


现在从 $n$ 个物品中，任取若干个装入箱内（也可以不取），使箱子的剩余空间最小。输出这个最小值。

#### 输入格式

第一行共一个整数 $V$，表示箱子容量。

第二行共一个整数 $n$，表示物品总数。

接下来 $n$ 行，每行有一个正整数，表示第 $i$ 个物品的体积。

#### 输出格式

- 共一行一个整数，表示箱子最小剩余空间。

#### 样例 #1

##### 样例输入 #1

```
24
6
8
3
12
7
9
7
```

##### 样例输出 #1

```
0
```

#### 提示

对于 $100\%$ 数据，满足 $0<n \le 30$，$1 \le V \le 20000$。

**【题目来源】**

NOIP 2001 普及组第四题

#### 题解

这个问题可以转化为这样的背包

物体容积为V，价值为V，求最优解。

那么这里V(体积，就是限制条件)就可作为dp状态，而dp记录的是最优解。  
由于本题目比较特殊$dp[v] = v$，所以这里我们可将其改为$dp[v] = 1$,然后使用与或非进行选择。


代码如下

```cpp
#include <iostream>

const int maxx = 20001;
int dp[201][maxx];

int main() {
  int V, n;
  std::cin >> V >> n;
  dp[0][0] = 1;
  for (int i = 1; i <= n; i++) {
    int v;
    scanf("%d", &v);
    for (int j = 0; j <= V; j++) {
      dp[i % 2][j] = dp[(i - 1) % 2][j];
      if (j - v < 0)
        continue;
      dp[i % 2][j] = dp[(i - 1) % 2][j] | dp[(i - 1) % 2][j - v];
    }
  }
  for (int i = V; i >= 0; i--) {
    if (dp[(n) % 2][i]) {
      std::cout << V - i << std::endl;
      return 0;
    }
  }
  return 0;
}
```


3. 背包问题也可以用来计数

```cpp
#include<iostream>

using namespace std;

const int maxx = 10000 + 1;
long long dp[100 + 1][maxx];  // dp[i][j]表示的是前i中菜点到j元有多少种
int main()
{
  int n,m;
  cin>>n>>m;
  dp[0][0] = 1;
  for(int i = 1;i<=n;i++){
    int val;
    scanf("%d",&val);
    for(int j = 0;j <= m;j++){
      dp[i][j] = dp[i - 1][j];
      if(j - val < 0)continue;
      dp[i][j] = dp[i - 1][j - val] + dp[i - 1][j];

    }
  }
  cout<<dp[n][m]<<endl;
  return 0;
}
// 下面是经过优化的代码。
/*
#include<iostream>

using namespace std;

const int maxx = 10000 + 1;
long long dp[maxx];
int main()
{
  int n,m;
  cin>>n>>m;
  dp[0] = 1;
  for(int i = 1;i<=n;i++){
    int val;
    scanf("%d",&val);
    for(int j = m;j >= 0;j--){
      if(j - val < 0)break;
      dp[j] += dp[j - val];

    }
  }
  cout<<dp[m]<<endl;
  return 0;
}
*/


```


4. 完全背包

完全背包问题的状态转移方程和01背包的思想不同，下面给出01背包形式的状态转移方程  
$dp[i][v]$表示当选择第i个物品的时候体积为v时价值最大的值。  
$vl[i]$表示的是体积，$p[i]$表示的是价值。

(1). 按照01背包的方式给出状态转移方程。
$$
dp[i][v] = max(dp[i - 1][v], dp[i - 1][v - k * vl[i]] + k * p[i])\\
k \in (0,+\infty)\\
v - k * vl[i] >= 0
$$

但是如果状态转移方程如上所示，时间复杂度将会达到$O(nt^2)$这个时间复杂度会在一些完全背包问题中超时。

(2). 另一种状态转移方程
$$ 
    dp[i][v] = max(dp[i - 1][v], dp[i][v - vl[i]] + p[i]);
$$ 
时间复杂度降低为了$O(nt)$，这个状态转移方程可以解释为dp[i][v]可以由没有选择第i类物品时的最值和可以选择第i类物品时最值决定(可以选择表示的是有可能选择。)

我们发现，如果要计算第i层的结果，就需要第i层的值，而01背包的dp转移方程是$dp[i][v] = max(dp[i - 1][v], dp[i - 1][v - vl[i]] + p[i])$这个是需要$dp[i - 1][v1] v1 < v$的结果的。如果进行维度压缩，那么在计算$dp[v]$之前，上一轮的结果$dp[v1] \&\& v1 < v$一定要存在，所以计算顺序是先计算v较大，但是完全背包不是这样子，所以完全背包计算顺序要按体积的正序计算，01背包使用倒序计算。

这里给出计算的代码


二维情况：
```cpp
int v[i],p[i];
for(int i = 0;i< n;i++){
    scanf("%d%d",&v[i],&p[i]);
    for(int j = 0;j <= v_max;j++){
        if(j - v[i] >= 0)
        dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + p[i]);
        else 
        dp[i][j] = dp[i -1][j];
    }
    
}
```
一维情况
```cpp
    int v[i],p[i];
    for(int i = 0;i < n;i++){
        scanf("%d%d",&v[i],&p[i]);
        for(int j = 0;j <= v_max;j++){
            if(j - v[i] < 0)continue;
            dp[j] = max(dp[j], dp[j - v[i]] + p[i]);
        }
    }
```

## 题目：
### 疯狂的采药

#### 题目背景

此题为纪念 LiYuxiang 而生。

#### 题目描述

LiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”

如果你是 LiYuxiang，你能完成这个任务吗？

此题和原题的不同点：

$1$. 每种草药可以无限制地疯狂采摘。

$2$. 药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！

#### 输入格式

输入第一行有两个整数，分别代表总共能够用来采药的时间 $t$ 和代表山洞里的草药的数目 $m$。

第 $2$ 到第 $(m + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数 $a_i, b_i$ 分别表示采摘第 $i$ 种草药的时间和该草药的价值。

#### 输出格式

输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。

#### 样例 #1

##### 样例输入 #1

```
70 3
71 100
69 1
1 2
```

##### 样例输出 #1

```
140
```

#### 提示

###### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $m \le 10^3$ 。
- 对于 $100\%$ 的数据，保证 $1 \leq m \le 10^4$，$1 \leq t \leq 10^7$，且 $1 \leq m \times t \leq 10^7$，$1 \leq a_i, b_i \leq 10^4$。

###### 答案

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxx = (int)1e7 + 10;
long long dp[maxx];
int main() {
  int t, m;
  cin >> t >> m;
  long long  ans = 0;
  for (int i = 0; i < m; i++) {
    int val_t, p;
    scanf("%d%d", &val_t, &p);
    for (int j = 0; j <= t; j++) {
      if (j - val_t >= 0)
        dp[j] = max(dp[j], dp[j - val_t] + p);
      ans = max(ans, dp[j]);
    }
  }
  cout<<ans<<endl;
  return 0;
}

```


