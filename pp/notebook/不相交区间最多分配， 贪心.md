# 不相交区间最多分配， 贪心

### uva1153

任务两个参数，1执行时长，2截止时间，问给出一组这样的任务，最多能执行多少任务。

```cpp
/*================================================================
*   Copyright (C) 2023 Sangfor Ltd. All rights reserved.
*   
*   filename：    uva1153.cpp
*   username:     skt1faker
*   create time:  09:34  2023.05.28
    email:        skk1faker@163.com
*   descripe:     
*
================================================================*/

#include<bits/stdc++.h>
using namespace std;
const int maxx = (int)8e5 +10;
struct node{
  int dur,en;
  bool operator < (const node & t)const{
    return dur < t.dur;
  }
}p[maxx];

bool cmp(const node &t1,const node &t2){
  return (t1.en == t2.en) ? t1.dur < t2.dur: t1.en < t2.en;
}

int main()
{
  int T;
  cin>>T;
  while(T--){
    int n;
    scanf("%d",&n);
    for(int i = 0;i < n;i++){
      scanf("%d%d",&p[i].dur,&p[i].en);
    }
    sort(p,p+n,cmp);
    int cnt = 0;
    priority_queue<node>q;
    for(int i = 0;i < n;i++){
      if(cnt + p[i].dur <= p[i].en){
        cnt += p[i].dur;
        q.push(p[i]);
      }
      else if(!q.empty()){
        node f = q.top();
        if(p[i].dur < f.dur){
          q.pop();
          q.push(p[i]);
          cnt += p[i].dur;
          cnt -= f.dur;
        }
      }
    }
    cout<<q.size()<<endl;
    if(T)cout<<endl;
  }
}

```

我们先给出答案的性质，答案中任务的执行顺序可以按照截止时间大小排序，同一截至时间的顺序随意。

![image-20230528104308547](/home/skt1faker/.config/Typora/typora-user-images/image-20230528104308547.png)



于是我们可以将任务按照截止时间排序，最终答案的执行顺序就应该是排序后结果的子序列。



我们始终维护当前位置的最优解， 即在执行数量最多的前提下，用时最少，用时最少是为了后续任务开始时间更早，能多作几个任务。

假设在s -1位置我们已经获得最优解，那么s位置的最优解如何获得，如果s可以直接加入当前最优解那么最好，这样执行数量会增加，此时的方案为s位置的最优解（如果存在加入s位置解A比现在得到的接更优，则s - 1位置的最优解可通过删除A中的s来获得s - 1处的解B（无论解A是由于是数量最多还是数量相同下时间最少的原因比当前解最优），此时的B一定是优于原来s - 1处的最优解，这与假设矛盾）， 如果不能直接加入说明需要将s - 1之前的执行任务删除一些（不需要调整顺序，因为之前证明了这种顺序是最优的），但是最多删除一个再将s加入，否则加入s之后会得到数量较少的解，不如s - 1之前的最优解原封不动的继承得到的解数量多。那么删除的时候删除哪一个好呢，答案是删除s - 1之前执行时间最长且大于s的任务，这样会使得所有任务执行时间最少，s - 1之前执行时间最长且大于s的任务如果不存在，那么s位置就不应该作为最优解的元素。一直这样维护，直到最后一个位置，我们就得到了最优解。

#### uva1153是上面例题

```cpp
/*================================================================
*   Copyright (C) 2023 Sangfor Ltd. All rights reserved.
*   
*   filename：    uva1153.cpp
*   username:     skt1faker
*   create time:  09:34  2023.05.28
    email:        skk1faker@163.com
*   descripe:     
*
================================================================*/

#include<bits/stdc++.h>
using namespace std;
const int maxx = (int)8e5 +10;
struct node{
  int dur,en;
  bool operator < (const node & t)const{
    return dur < t.dur;
  }
}p[maxx];

bool cmp(const node &t1,const node &t2){
  return t1.en < t2.en;
}

int main()
{
  int T;
  cin>>T;
  while(T--){
    int n;
    scanf("%d",&n);
    for(int i = 0;i < n;i++){
      scanf("%d%d",&p[i].dur,&p[i].en);
    }
    sort(p,p+n,cmp);
    int cnt = 0;
    priority_queue<node>q;
    for(int i = 0;i < n;i++){
      if(cnt + p[i].dur <= p[i].en){
        cnt += p[i].dur;
        q.push(p[i]);
      }
      else if(!q.empty()){
        node f = q.top();
        if(p[i].dur < f.dur){
          q.pop();
          q.push(p[i]);
          cnt += p[i].dur;
          cnt -= f.dur;
        }
      }
    }
    cout<<q.size()<<endl;
    if(T)cout<<endl;
  }
}

```

## 给出一大堆区间，求最多不相交的区间个数。

将区间按照结束坐标排序，对于排序好的前i个区间，可以通过i - 1个区间的最优解得出，假设前i个区间的最优解为不相交区间数量最多的解，在多解的情况下，区间结束位置越小越好（因为这样可以给后面更多的位置），考虑i位置是否加入，如果当前加入无压力，说明当前为最优解（如果还有一种方案A选择了i但是区间的数量比当前方案多，则可将这个方案A去除后作为前i - 1个元素的最优解），否则若要将i区间加入需要将原i - 1的最优解删除至多一个区间，将i加入，但是这种情况会使得最优解结束位置较大，使得后面位置分配空间较小，不能获得最优解。

### 洛谷p1083上述例题

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxx = (int)1e5 + 10;
struct Inter
{
  int l,r;
  bool operator < (const Inter & temp){
    return this->r < temp.r;
  }
}inter[maxx];

int main()
{
  int n;
  scanf("%d",&n);
  for(int i = 0;i < n;i++){
    scanf("%d%d",&inter[i].l,&inter[i].r);
  }
  sort(inter, inter + n);
  int last_posi = -1;
  int ans = 0;
  // 流出更大的空间，证明过程。
  for(int i = 0;i < n;i++){
    if(inter[i].l >= last_posi){
      last_posi = inter[i].r;
      ans++;
    }
  }
  cout<<ans<<endl;
  return 0;
}
```

