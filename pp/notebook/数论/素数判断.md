# mr素数判断
```cpp
/*================================================================
*   Copyright (C) 2023 Sangfor Ltd. All rights reserved.
*
*   filename：    57677.cpp
*   username:     skt1faker
*   create time:  21:28  2023.06.20
    email:        skk1faker@163.com
*   descripe:
*
================================================================*/

#include <bits/stdc++.h>
using namespace std;
#define ll long long

bool mr(ll x, ll prim) {
  ll mod = prim;
  ll mul = 1;
  prim--;
  while (prim) {
    if (prim & 1) {
      mul *= x;
      mul %= mod;
    }
    x *= x;
    x %= mod;
    prim /= 2;
  }
  return mul == 1; // 为质数
}

bool is_prime(ll x) {
  int prime[9] = {2, 3, 5, 7, 11,13,15,17,19};		// 这里的数一定要足够
  for (int i = 0; i < 9; i++) {
    if(x == prime[i])return true;
    if (!mr(prime[i], x))
      return false;
  }
  return true;
}

int main() {
  int n;
  cin >> n;
  for (int i = 0; i < n; i++) {
    ll temp_val;
    scanf("%lld", &temp_val);
     if(temp_val == 0){
         
         cout<<0<<endl;
     }
    else if (temp_val == 1) {
      cout << 1 << endl;
    } else if (temp_val == 4) {
      cout << 4 << endl;
    } else
      for (ll x = temp_val; x >= 2; x--) {
        if (is_prime(x)) {
          printf("%lld\n", x);
          break;
        }
      }
  }
  return 0;
}
```

mr素数判定主要使用了费马定理

如果p为素数，gcd(p,a) == 1,即

a不是p的倍数，那么
$$
a ^{p - 1} = 1 mod(p)
$$
注意这个式子成立是p为素数的必要条件，所以其成立不可证明其为素数，但是上式不成立时p一定为合数。

mr算法认为存在多个a使得上面等式成立时，p有很大概率为质数。

因为质数和任意的数gcd后都为1，所以这里取式子中的a为质数，取出一组素数，然后作如下判断：

```cpp
bool mr(ll x, ll prim) {
  ll mod = prim;
  ll mul = 1;
  prim--;
  while (prim) {
    if (prim & 1) {
      mul *= x;
      mul %= mod;
    }
    x *= x;
    x %= mod;
    prim /= 2;
  }
  return mul == 1; // 为质数
}

bool is_prime(ll x) {
  int prime[9] = {2, 3, 5, 7, 11,13,15,17,19};		// 这里的数一定要足够
  for (int i = 0; i < 9; i++) {
    if(x == prime[i])return true;
    if (!mr(prime[i], x))
      return false;
  }
  return true;
}
```