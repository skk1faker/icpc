作者：我只想做一只懒猫
链接：https://www.zhihu.com/question/20806796/answer/159392465
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



Hash(N) = N % M首先，我们要明白Hash的意义在于把一个大的集合A，映射到小的集合B。比如通过取余的方式进行Hash，集合A = {0, 1, …, M, M+1, …, 2*M, 2*M+1, …, 3*M, 3*M+1, …}就会被映射到集合B = {0, 1, 2, …, M - 1}。然后，如果集合A的元素分布是{0, 1, 2, 3, 4, …}这样的话，M取质数还是合数都可以，最后整个集合A会被均匀地映射到{0, 1, …, M-1}。（例子）但是，很多情况下我们的元素分布是有非1步长的，比如集合A = {0, 6, 12, 18, 24, 30, 36, …}，这时候就出现问题了。当M取合数时，比如M = 10，我们来看看映射的情况。0->0, 6->6, 12->2, 18->8, 24->4, 30->0, 36->6, …。此时我们很容易发现，最后映射到了集合B = {0, 6, 2, 8, 4} = {0, 2, 4, 6, 8}，和我们理想中的{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}差距很大啊。有问题我们就要去解决啊。我们回到代数形式上来看，**在N与M最大公因数为1的情况下**，N % M后可以得到的一系列的余数r，而全体余数r的集合R就是{0, 1, 2, …, M-1}。每个余数r代表了一个N的集合，比如在上面的例子中余数0代表了N的集合{0, 10, 20, 30, …}，这个集合就叫做“同余类”。即余数集合R中有M个余数，每个余数r代表一个同余类。现在思路就很清晰了，我们最理想的方式就是将集合A映射到余数集合R上，即B = R。接下来我们讨论一下为什么有时候无法完全利用余数集合R：假设N = kn, M = km， N和M存在最大公因数k，此时可以将N % M = r转化为公式N = Mq + r，即kn = kmq + r。其中q是商，r是余数。**“表面上”**r的取值范围是{0, 1, 2, …, M-1}（忽视了只有N与M最大公因数为1时，才能取整个余数集合R的定理），一片和谐。但是可以对公式进行稍微的变换，n = mq + (r/k)，由于n和mq都是整数，则(r/k)也是整数。此时我们看一看到(r/k)的取值范围是{0, 1, 2, …, m} = {0, 1, 2, …, M/k}。恢复到原式，也是就r的**“实际”**取值范围是{0, k, 2*k, 3*k, …, m*k}，缩小了k倍。一切都明了了，我们最后的目标就是保证N与M最大公因数为1。最简单的方式就是直接取M为质数！

