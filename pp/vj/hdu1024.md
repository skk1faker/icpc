## 题解

&emsp;&emsp;动态规划就是通过状态转移来计算我们的最优解，这里说的状态其实也是某一类问题，比如说“从0到i的元素某种运算的最值记为dp[i]，这个i我们可以把它叫做一个状态，他是这类问题的一个状态”，最开始的状态是很好计算的（如刚刚的问题，0到0元素的某种运算的最值一定是只有第0个元素参与），后面的计算就通过状态转移就可以了，只要得到合适的状态就能建立状态转移方程。 为什么要建立状态呢，原因是再计算其他状态的时候，可能会多次利用i状态（利用i状态计算这个过程就是状态转移，即从多个状态计算某一个状态），这个时候如果记录下来这个状态将会大大降低计算量（这也是所谓的用空间换时间的思想）。
&emsp;&emsp;如何寻找一个状态，这个可能会靠一些经验，有时候也需要分析。我们来分析一下这个问题，对于一个数列$x_1,x_2....x_n$，现在分为了m段（此时这m段的和是最大值）如果我添加一个元素$x_{n+1}$，我们思考一下他可能会怎样影响多段和最值的变化。假如说第m段没有选择新添加的$x_{n+1}$，那么其选择和原来没有影响，如果有影响那么元素[0，n]的最值一定不成立，如果选择$x_{n+1}$了分析如下：
```cpp
元素如下,[1]表示x1：
[[1] [2] [3] ... [m - 1]     [m    ]]
|                      |     |     | 
0                   r(m-1)  l(m)   r(m) == n
```

首先，如果确定一个序列的m段的最值m段的位置之后，第m段的左边界$l(m)$前的m-1段一定是$[0,l(m)-1]$序列的一个m-1段的最值，否则我可以将$[0,l(m)-1]$处换为m-1段的最值使得[0,n+1]的m段和总体达到最大（刚刚这个是一个反证法，离散问题常用反证法证明，反证法是这样的，我们想用条件A->结论B，正向推不出来我们可以使用 非结论B->非条件A进行证明,这就是数学上所谓的一个命题和其逆否命题同真假），有了这个结论我们想，如果我们加入了$a_{n+1}$那么第m段的左边界应该在那里呢，我们不知道，所以可以枚举，这也就是状态转移的依据，转移需要的信息就是我们的状态信息，转移需要什么信息了呢？l(m)前的m-1段最大值就是状态转移的信息。将这个状态通俗的说就是
dp[i][j] 表示的是[0--j]分为i段的最大值

刚刚的状态转移方程就可以$dp[a][b] = max(dp[a][b - 1] , max(dp[a-1][c] + sum(c+1,b))，(c \in [0,b-1]))$,这里的sum(c+1,b)表示将c+1到b元素的总和求解。
其中dp[a][b - 1]表示不选择b元素的情况，后面的$max(dp[a-1][c] + sum(c+1,b))，(c \in [0,b-1])$表示选择b元素但是在枚举第m段的左边界。
其中$dp[i][i-1]$表示的是前i个元素分为i段，那么其值一定是$sum(0,i-1)$这个可作为dp状态转移前的初始值（必须有初始值才能通过状态转移得到其他状态的值）

分析一下时间复杂度，假设有n个元素，m段，需要计算mn个dp[a][b]，每个dp计算需要时间O(n)，所以时间为$O(n^2m)$，这个时间一定会超时的，问题出现在了每个dp计算时间需要O(n)上，如何进行优化呢？

观察状态转移公式
$$dp[a][b] = max(dp[a][b - 1] , max(dp[a-1][c] + sum(c+1,b))，(c \in [0,b-1]))$$

其中
$$\begin{aligned}
&max(dp[a-1][c] + sum(c+1,b))，(c \in [0,b-1])\\
&max(dp[a-1][c] + sum(1,b) - sum(1,c))，(c \in [0,b-1])\\
&由于b在max函数中一直是一个不变量，所以可以拿出来\\
&max(dp[a-1][c] - sum(1,c))，(c \in [0,b-1]) + sum(1,b)\\
\end{aligned}$$

于是我们可以在求解dp[a-1][b]的时候数顺便可以求出$dp\_max[a-1][b - 1] = max(dp[a-1][c] - sum(1,c))，(c \in [0,b-1])$（这个求解过程看我代码吧，你会理解的，不理解晚上和你说）


## 代码
使用这份代码可能会发生内存超限，其主要原因也是m并没有给出范围。但这个是比较方便看的一份代码，所以可先看这份代码
```cpp
#include<iostream>
#define ll long long 
using namespace std;
const int max_n = (int)1e6 + 10;
const int max_m = (int)1e2 + 10;

ll dp[max_m][max_n];
ll dp_max[max_m][max_n];
ll sum[max_n];
int main()
{
	int m,n;
	while(scanf("%d%d",&m,&n) == 2){
		sum[0] = 0;// 必须有这句，不然下面没有办法继续
		for(int i = 1;i <= n;i++){
			ll temp_ele;
			scanf("%lld",&temp_ele);
			sum[i] = sum[i - 1] + temp_ele;
		}
		// 对dp初始化的时候就考虑dp的含义就可以，至于初始化哪个状态，这要看状态转移公式第一个需要的值是谁，如果不清楚第一个值是谁，可以画图看计算方向（将每个状态用坐标表示，观察计算方向）。
		for(int i = 0;i <= n; ++i){
			dp[0][i] = 0;//段长为0，值为0
			dp_max[0][i] = max(dp_max[0][i - 1], dp[0][i] - sum[i]);
		}
		for(int i = 1;i <= m;i++){
			dp[i][i] = sum[i];	// dp初始化，每段只有一个元素
			dp_max[i][i] = dp[i][i] - sum[i];
			for(int j = i+1;j <= n;j++){
				dp[i][j] = max(dp[i][j-1], dp_max[(i-1)][j - 1] + sum[j]); 
				dp_max[i][j] = max(dp_max[i][j - 1], dp[i][j] - sum[j]);
			}
		}
		cout<<dp[m][n]<<endl;
	}
	return 0;
}
```
经过观察发现，对于dp存储的数据我们始终使用dp[i][?]一行历史数据来计算新的一行dp[i+1][?]数据，根据这一点我们可以进行空间上的优化，见下面

```cpp
#include<iostream>
#define ll long long 
using namespace std;
const int max_n = (int)1e6 + 10;
const int max_m = (int)2;
ll dp[max_m][max_n];
ll dp_max[max_m][max_n];
ll sum[max_n];
int main()
{
	int m,n;
	while(scanf("%d%d",&m,&n) == 2){
		sum[0] = 0;// 必须有这句，不然下面没有办法继续
		for(int i = 1;i <= n;i++){
			ll temp_ele;
			scanf("%lld",&temp_ele);
			sum[i] = sum[i - 1] + temp_ele;
		}
		// 对dp初始化的时候就考虑dp的含义就可以，至于初始化哪个状态，这要看状态转移公式第一个需要的值是谁，如果不清楚第一个值是谁，可以画图看计算方向（将每个状态用坐标表示，观察计算方向）。
		for(int i = 0;i <= n; ++i){
			dp[0][i] = 0;//段长为0，值为0
			dp_max[0][i] = max(dp_max[0][i - 1], dp[0][i] - sum[i]);
		}
		for(int i = 1;i <= m;i++){
			dp[i%2][i] = sum[i];	// dp初始化，每段只有一个元素
			dp_max[i%2][i] = dp[i%2][i] - sum[i];
			for(int j = i+1;j <= n;j++){
				dp[i%2][j] = max(dp[i%2][j-1], dp_max[(i-1)%2][j - 1] + sum[j]); 
				dp_max[i%2][j] = max(dp_max[i%2][j - 1], dp[i%2][j] - sum[j]);
			}
		}
		cout<<dp[m%2][n]<<endl;
	}
	return 0;
}
```